// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'tag_info.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

TagInfo _$TagInfoFromJson(Map<String, dynamic> json) {
  return _TagInfo.fromJson(json);
}

/// @nodoc
mixin _$TagInfo {
  int get antennaId => throw _privateConstructorUsedError;
  int get frequency => throw _privateConstructorUsedError;
  int get timeStamp => throw _privateConstructorUsedError;
  int get embeddedDatalen => throw _privateConstructorUsedError;
  List<int> get embeddedData => throw _privateConstructorUsedError;
  int get epclen => throw _privateConstructorUsedError;
  List<int> get pc => throw _privateConstructorUsedError;
  List<int> get crc => throw _privateConstructorUsedError;
  String get epcId => throw _privateConstructorUsedError;
  int get phase => throw _privateConstructorUsedError;

  /// Serializes this TagInfo to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of TagInfo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TagInfoCopyWith<TagInfo> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TagInfoCopyWith<$Res> {
  factory $TagInfoCopyWith(TagInfo value, $Res Function(TagInfo) then) =
      _$TagInfoCopyWithImpl<$Res, TagInfo>;
  @useResult
  $Res call(
      {int antennaId,
      int frequency,
      int timeStamp,
      int embeddedDatalen,
      List<int> embeddedData,
      int epclen,
      List<int> pc,
      List<int> crc,
      String epcId,
      int phase});
}

/// @nodoc
class _$TagInfoCopyWithImpl<$Res, $Val extends TagInfo>
    implements $TagInfoCopyWith<$Res> {
  _$TagInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TagInfo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? antennaId = null,
    Object? frequency = null,
    Object? timeStamp = null,
    Object? embeddedDatalen = null,
    Object? embeddedData = null,
    Object? epclen = null,
    Object? pc = null,
    Object? crc = null,
    Object? epcId = null,
    Object? phase = null,
  }) {
    return _then(_value.copyWith(
      antennaId: null == antennaId
          ? _value.antennaId
          : antennaId // ignore: cast_nullable_to_non_nullable
              as int,
      frequency: null == frequency
          ? _value.frequency
          : frequency // ignore: cast_nullable_to_non_nullable
              as int,
      timeStamp: null == timeStamp
          ? _value.timeStamp
          : timeStamp // ignore: cast_nullable_to_non_nullable
              as int,
      embeddedDatalen: null == embeddedDatalen
          ? _value.embeddedDatalen
          : embeddedDatalen // ignore: cast_nullable_to_non_nullable
              as int,
      embeddedData: null == embeddedData
          ? _value.embeddedData
          : embeddedData // ignore: cast_nullable_to_non_nullable
              as List<int>,
      epclen: null == epclen
          ? _value.epclen
          : epclen // ignore: cast_nullable_to_non_nullable
              as int,
      pc: null == pc
          ? _value.pc
          : pc // ignore: cast_nullable_to_non_nullable
              as List<int>,
      crc: null == crc
          ? _value.crc
          : crc // ignore: cast_nullable_to_non_nullable
              as List<int>,
      epcId: null == epcId
          ? _value.epcId
          : epcId // ignore: cast_nullable_to_non_nullable
              as String,
      phase: null == phase
          ? _value.phase
          : phase // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TagInfoImplCopyWith<$Res> implements $TagInfoCopyWith<$Res> {
  factory _$$TagInfoImplCopyWith(
          _$TagInfoImpl value, $Res Function(_$TagInfoImpl) then) =
      __$$TagInfoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int antennaId,
      int frequency,
      int timeStamp,
      int embeddedDatalen,
      List<int> embeddedData,
      int epclen,
      List<int> pc,
      List<int> crc,
      String epcId,
      int phase});
}

/// @nodoc
class __$$TagInfoImplCopyWithImpl<$Res>
    extends _$TagInfoCopyWithImpl<$Res, _$TagInfoImpl>
    implements _$$TagInfoImplCopyWith<$Res> {
  __$$TagInfoImplCopyWithImpl(
      _$TagInfoImpl _value, $Res Function(_$TagInfoImpl) _then)
      : super(_value, _then);

  /// Create a copy of TagInfo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? antennaId = null,
    Object? frequency = null,
    Object? timeStamp = null,
    Object? embeddedDatalen = null,
    Object? embeddedData = null,
    Object? epclen = null,
    Object? pc = null,
    Object? crc = null,
    Object? epcId = null,
    Object? phase = null,
  }) {
    return _then(_$TagInfoImpl(
      antennaId: null == antennaId
          ? _value.antennaId
          : antennaId // ignore: cast_nullable_to_non_nullable
              as int,
      frequency: null == frequency
          ? _value.frequency
          : frequency // ignore: cast_nullable_to_non_nullable
              as int,
      timeStamp: null == timeStamp
          ? _value.timeStamp
          : timeStamp // ignore: cast_nullable_to_non_nullable
              as int,
      embeddedDatalen: null == embeddedDatalen
          ? _value.embeddedDatalen
          : embeddedDatalen // ignore: cast_nullable_to_non_nullable
              as int,
      embeddedData: null == embeddedData
          ? _value._embeddedData
          : embeddedData // ignore: cast_nullable_to_non_nullable
              as List<int>,
      epclen: null == epclen
          ? _value.epclen
          : epclen // ignore: cast_nullable_to_non_nullable
              as int,
      pc: null == pc
          ? _value._pc
          : pc // ignore: cast_nullable_to_non_nullable
              as List<int>,
      crc: null == crc
          ? _value._crc
          : crc // ignore: cast_nullable_to_non_nullable
              as List<int>,
      epcId: null == epcId
          ? _value.epcId
          : epcId // ignore: cast_nullable_to_non_nullable
              as String,
      phase: null == phase
          ? _value.phase
          : phase // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TagInfoImpl extends _TagInfo {
  const _$TagInfoImpl(
      {required this.antennaId,
      required this.frequency,
      required this.timeStamp,
      required this.embeddedDatalen,
      required final List<int> embeddedData,
      required this.epclen,
      required final List<int> pc,
      required final List<int> crc,
      required this.epcId,
      required this.phase})
      : _embeddedData = embeddedData,
        _pc = pc,
        _crc = crc,
        super._();

  factory _$TagInfoImpl.fromJson(Map<String, dynamic> json) =>
      _$$TagInfoImplFromJson(json);

  @override
  final int antennaId;
  @override
  final int frequency;
  @override
  final int timeStamp;
  @override
  final int embeddedDatalen;
  final List<int> _embeddedData;
  @override
  List<int> get embeddedData {
    if (_embeddedData is EqualUnmodifiableListView) return _embeddedData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_embeddedData);
  }

  @override
  final int epclen;
  final List<int> _pc;
  @override
  List<int> get pc {
    if (_pc is EqualUnmodifiableListView) return _pc;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_pc);
  }

  final List<int> _crc;
  @override
  List<int> get crc {
    if (_crc is EqualUnmodifiableListView) return _crc;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_crc);
  }

  @override
  final String epcId;
  @override
  final int phase;

  @override
  String toString() {
    return 'TagInfo(antennaId: $antennaId, frequency: $frequency, timeStamp: $timeStamp, embeddedDatalen: $embeddedDatalen, embeddedData: $embeddedData, epclen: $epclen, pc: $pc, crc: $crc, epcId: $epcId, phase: $phase)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TagInfoImpl &&
            (identical(other.antennaId, antennaId) ||
                other.antennaId == antennaId) &&
            (identical(other.frequency, frequency) ||
                other.frequency == frequency) &&
            (identical(other.timeStamp, timeStamp) ||
                other.timeStamp == timeStamp) &&
            (identical(other.embeddedDatalen, embeddedDatalen) ||
                other.embeddedDatalen == embeddedDatalen) &&
            const DeepCollectionEquality()
                .equals(other._embeddedData, _embeddedData) &&
            (identical(other.epclen, epclen) || other.epclen == epclen) &&
            const DeepCollectionEquality().equals(other._pc, _pc) &&
            const DeepCollectionEquality().equals(other._crc, _crc) &&
            (identical(other.epcId, epcId) || other.epcId == epcId) &&
            (identical(other.phase, phase) || other.phase == phase));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      antennaId,
      frequency,
      timeStamp,
      embeddedDatalen,
      const DeepCollectionEquality().hash(_embeddedData),
      epclen,
      const DeepCollectionEquality().hash(_pc),
      const DeepCollectionEquality().hash(_crc),
      epcId,
      phase);

  /// Create a copy of TagInfo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TagInfoImplCopyWith<_$TagInfoImpl> get copyWith =>
      __$$TagInfoImplCopyWithImpl<_$TagInfoImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TagInfoImplToJson(
      this,
    );
  }
}

abstract class _TagInfo extends TagInfo {
  const factory _TagInfo(
      {required final int antennaId,
      required final int frequency,
      required final int timeStamp,
      required final int embeddedDatalen,
      required final List<int> embeddedData,
      required final int epclen,
      required final List<int> pc,
      required final List<int> crc,
      required final String epcId,
      required final int phase}) = _$TagInfoImpl;
  const _TagInfo._() : super._();

  factory _TagInfo.fromJson(Map<String, dynamic> json) = _$TagInfoImpl.fromJson;

  @override
  int get antennaId;
  @override
  int get frequency;
  @override
  int get timeStamp;
  @override
  int get embeddedDatalen;
  @override
  List<int> get embeddedData;
  @override
  int get epclen;
  @override
  List<int> get pc;
  @override
  List<int> get crc;
  @override
  String get epcId;
  @override
  int get phase;

  /// Create a copy of TagInfo
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TagInfoImplCopyWith<_$TagInfoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
